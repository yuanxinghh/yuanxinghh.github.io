(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[408],{2766:function(e,n,s){Promise.resolve().then(s.bind(s,3375))},3375:function(e,n,s){"use strict";s.d(n,{default:function(){return y}});var t=s(7573),o=s(7659),r=s(9665),i=s(1241),a=s(706);let l={master:{volume:.5},common:{preload:!1,disabled:!1},categories:{background:{volume:.25},transition:{volume:.5},interaction:{volume:.75},notification:{volume:1}},bleeps:{hover:{category:"background",sources:[{src:"/assets/sounds/hover.webm",type:"audio/webm"},{src:"/assets/sounds/hover.mp3",type:"audio/mpeg"}]},click:{category:"interaction",sources:[{src:"/assets/sounds/click.webm",type:"audio/webm"},{src:"/assets/sounds/click.mp3",type:"audio/mpeg"}]}}},c=()=>{let e=(0,a.s0)();return(0,t.jsx)(a.fS,{as:"button",className:(0,a.cx)("inline-flex border px-4 py-2","border-primary-main-5 text-primary-main-3 bg-primary-main-3/20"),onMouseEnter:()=>{var n;null===(n=e.hover)||void 0===n||n.play()},onClick:()=>{var n;null===(n=e.click)||void 0===n||n.play()},children:"Hover or click me!"})},p=()=>(0,t.jsx)(a.ix,{...l,children:(0,t.jsx)(a.LH,{children:(0,t.jsx)("div",{children:(0,t.jsx)(c,{})})})});var d=s(7653);let m={master:{volume:.5},common:{preload:!1,disabled:!1},categories:{background:{volume:.25},transition:{volume:.5},interaction:{volume:.75},notification:{volume:1}},bleeps:{type:{category:"transition",sources:[{src:"/assets/sounds/type.webm",type:"audio/webm"},{src:"/assets/sounds/type.mp3",type:"audio/mpeg"}]}}},u=()=>{let[e,n]=(0,d.useState)(!1),[s,o]=(0,d.useState)(!1),r=(0,d.useRef)(null);return(0,d.useEffect)(()=>{let e=setTimeout(()=>o(!s),s?3e3:1e3);return()=>clearTimeout(e)},[s]),(0,d.useEffect)(()=>{let e=new IntersectionObserver(e=>{for(let s of e)n(s.isIntersecting)});return e.observe(r.current),()=>e.disconnect()},[]),(0,t.jsx)(a.LH,{root:!0,active:e&&s,children:(0,t.jsx)(a.fS,{className:"flex flex-col gap-2 px-8 py-2 bg-primary-main-7/10",hideOnExited:!1,children:(0,t.jsxs)(a.xv,{elementRef:r,children:[(0,t.jsx)(a.tu,{transitions:{entering:"type",exiting:"type"}}),"The bleep will play on the animator state changes to enter and exit."]})})})},h=()=>(0,t.jsx)(a.QS,{disabled:!1,dismissed:!1,children:(0,t.jsx)(a.ix,{...m,children:(0,t.jsx)("div",{children:(0,t.jsx)(u,{})})})});var y=()=>(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.AR.Header,{children:"React Bleeps"}),(0,t.jsxs)(i.AR.P,{children:["ARWES provides the Bleeps API to manage short sound effects in an app. Make sure to read the"," ",(0,t.jsx)(o.default,{href:"/docs/develop/fundamentals/audio",children:"audio fundamentals"})," for context."]}),(0,t.jsx)(i.AR.H2,{children:"Type Safety"}),(0,t.jsx)(i.AR.P,{children:"To constraint the names of the bleeps to use for an app, an union type can be used:"}),(0,t.jsx)(i.AR.CodeBlock,{filename:"types.ts",lang:"tsx",code:"// List of sound names for type safety.\nexport type BleepsNames = 'hover' | 'type' | 'click' | 'error'"}),(0,t.jsx)(i.AR.H2,{children:"Bleeps Provider"}),(0,t.jsx)(i.AR.P,{children:"For most apps, creating an audio configuration and providing it to all components is sufficient."}),(0,t.jsx)(i.AR.CodeBlock,{filename:"App.tsx",lang:"tsx",code:"import { type BleepsProviderSettings, BleepsProvider } from '@arwes/react'\n\n// Import the previous bleeps names type.\nimport type { BleepsNames } from './types.ts'\n\nconst bleepsSettings: BleepsProviderSettings<BleepsNames> = {\n  master: {\n    volume: 0.5 // 50% of operating system volume.\n  },\n  common: {\n    disabled: false\n  },\n  categories: { // Relative to the `master` settings.\n    background: { volume: 0.25 },\n    transition: { volume: 0.5 },\n    interaction: { volume: 0.75 },\n    notification: { volume: 1 }\n  },\n  bleeps: {\n    hover: {\n      category: 'background',\n      // List of sound assets by priority for compatibility.\n      sources: [\n        { src: '/sounds/hover.webm', type: 'audio/webm' },\n        { src: '/sounds/hover.mp3', type: 'audio/mpeg' }\n      ]\n    },\n    type: {\n      category: 'transition',\n      sources: [\n        { src: '/sounds/type.webm', type: 'audio/webm' },\n        { src: '/sounds/type.mp3', type: 'audio/mpeg' }\n      ],\n      loop: true\n    },\n    click: {\n      category: 'interaction',\n      sources: [\n        { src: '/sounds/click.webm', type: 'audio/webm' },\n        { src: '/sounds/click.mp3', type: 'audio/mpeg' }\n      ]\n    },\n    error: {\n      category: 'notification',\n      sources: [\n        { src: '/sounds/error.webm', type: 'audio/webm' },\n        { src: '/sounds/error.mp3', type: 'audio/mpeg' }\n      ]\n    }\n  }\n}\n\nconst App = (): JSX.Element => (\n  <BleepsProvider {...bleepsSettings}>\n    {/* ... */}\n  </BleepsProvider>\n)"}),(0,t.jsx)(i.AR.H2,{children:"Bleeps Consumers"}),(0,t.jsx)(i.AR.P,{children:"Once bleeps are provided to components, they can play them."}),(0,t.jsx)(i.AR.CodeBlock,{filename:"Button.tsx",lang:"tsx",code:"import { useBleeps } from '@arwes/react'\nimport type { BleepsNames } from './types.ts'\n\nconst Button = (): JSX.Element => {\n  const bleeps = useBleeps<BleepsNames>()\n  return (\n    <button\n      onMouseEnter={() => {\n        // In case the bleeps are disabled, always check if they are provided.\n        bleeps.hover?.play()\n      }}\n      onClick={() => {\n        bleeps.click?.play()\n      }}\n    >\n      Hover or click me!\n    </button>\n  )\n}"}),(0,t.jsx)(p,{}),(0,t.jsx)(i.AR.H2,{children:(0,t.jsx)("code",{children:"<BleepsOnAnimator>"})}),(0,t.jsx)(i.AR.P,{children:"Bleeps can play declaratively on an animator state change."}),(0,t.jsx)(i.AR.CodeBlock,{filename:"Content.tsx",lang:"tsx",code:"import { Animator, Text, BleepsOnAnimator } from '@arwes/react'\nimport type { BleepsNames } from './types.ts'\n\nconst Content = (): JSX.Element => (\n  <Animator>\n    <BleepsOnAnimator<BleepsNames>\n      transitions={{ entering: 'type', exiting: 'type' }}\n    />\n    <Text>\n      The bleep will play on the animator state changes to enter and exit.\n    </Text>\n  </Animator>\n)"}),(0,t.jsx)(h,{}),(0,t.jsxs)(i.AR.P,{children:[(0,t.jsx)("code",{children:"continuous={true}"})," prop can be used to play bleeps even after the state specified changes. For non-loop bleeps which have longer audio durations than the animator state change duration."]}),(0,t.jsxs)(i.AR.P,{children:["Check out the"," ",(0,t.jsxs)("a",{href:"/play",children:[(0,t.jsx)(r.Z,{})," Playground"]})," ","for more examples."]}),(0,t.jsx)(i.AR.Navigation,{prevHref:"/docs/develop/react/animators",prev:"Animators",nextHref:"/docs/develop/react/text",next:"Text"})]})}},function(e){e.O(0,[548,109,86,527,706,241,293,286,744],function(){return e(e.s=2766)}),_N_E=e.O()}]);